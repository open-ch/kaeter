package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/open-ch/kaeter/change"
	"github.com/open-ch/kaeter/log"
	"github.com/open-ch/kaeter/modules"
)

// Result holds the structure of the JSON output generated by the command
type Result struct {
	Modules    map[string]modules.KaeterModule `json:"Modules"` // Modules is uppercase here for backwards compatibility
	duplicates []string
}

func getCIDetectChangesCommand() *cobra.Command {
	var changesFile string
	var modulesFile string
	var currentCommit string
	var previousCommit string
	var pullRequest change.PullRequest
	var skipModulesDetection bool
	var skipChangesDetection bool

	detectCmd := &cobra.Command{
		Use:   "detect-changes",
		Short: "Combined command to detect all modules and changes",
		Long: `This command extracts all the kaeter modules and runs change detection.
It will out put both a modules.json and a changeset.json file.

Previously called "kaeter-ci detect-all".
`,
		RunE: func(_ *cobra.Command, _ []string) error {
			repositoryPath := viper.GetString("repoRoot")
			kaeterModules, err := modules.GetKaeterModules(repositoryPath)
			if err != nil {
				return fmt.Errorf("failed to detect kaeter modules: %w", err)
			}
			if !skipModulesDetection {
				err = saveModulesToFile(kaeterModules, repositoryPath, modulesFile)
				if err != nil {
					return fmt.Errorf("modules detection failed: %w", err)
				}
				log.Infof("Modules found saved to %s", modulesFile)

				if skipChangesDetection {
					return nil
				}
			}

			detector := &change.Detector{
				RootPath:       repositoryPath,
				PreviousCommit: previousCommit,
				CurrentCommit:  currentCommit,
				KaeterModules:  kaeterModules,
				PullRequest:    &pullRequest,
			}
			err = runChangeDetection(detector, changesFile)
			if err != nil {
				return fmt.Errorf("change detection failed: %w", err)
			}
			return nil
		},
	}

	flags := detectCmd.Flags()
	flags.StringVar(&previousCommit, "previous-commit", "HEAD~1", "The previous commit")
	flags.StringVar(&currentCommit, "latest-commit", "HEAD", "The current commit")
	flags.StringVar(&pullRequest.Title, "pr-title", "", "Optional: if a pull request is open, the title")
	flags.StringVar(&pullRequest.Body, "pr-body", "", "Optional: if a pull request is open, the body")
	flags.StringVar(&changesFile, "changes-output", "./changeset.json", "The path to the file containing the change information")
	flags.StringVar(&modulesFile, "modules-output", "./modules.json", "The path to the file containing the module information")

	flags.BoolVar(&skipModulesDetection, "changes-only", false, "Skips saving the modules.json file")
	flags.BoolVar(&skipChangesDetection, "modules-only", false, "Skips change detection and saving changeset.json")
	detectCmd.MarkFlagsMutuallyExclusive("changes-only", "modules-only")

	return detectCmd
}

func runChangeDetection(detector *change.Detector, outputFile string) error {
	if !filepath.IsAbs(outputFile) {
		outputFile = filepath.Join(detector.RootPath, outputFile)
	}

	changeset, err := detector.Check()
	if err != nil {
		return err
	}

	//nolint:musttag
	changesetJSON, err := json.MarshalIndent(changeset, "", "    ")
	if err != nil {
		return err
	}
	log.Info(string(changesetJSON))

	//nolint:gomnd
	return os.WriteFile(outputFile, changesetJSON, 0600)
}

func saveModulesToFile(kaeterModules []modules.KaeterModule, repositoryPath, outputFile string) error {
	result := new(Result)
	result.Modules = make(map[string]modules.KaeterModule)

	// Transform the slice of modules into a map and detect duplicates
	for _, module := range kaeterModules {
		if _, found := result.Modules[module.ModuleID]; found {
			result.duplicates = append(result.duplicates, module.ModuleID)
			log.Debugf("Duplicate module ID found: %s", module.ModuleID)
		}
		result.Modules[module.ModuleID] = module
	}
	if result.duplicates != nil {
		return fmt.Errorf("duplicate module IDs found: %s", strings.Join(result.duplicates, ", "))
	}

	resultJSON, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		return err
	}

	if !filepath.IsAbs(outputFile) {
		outputFile = filepath.Join(repositoryPath, outputFile)
	}

	//nolint:gomnd
	return os.WriteFile(outputFile, resultJSON, 0600)
}
