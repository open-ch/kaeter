package actions

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"regexp"
	"strings"
	"text/template"

	"github.com/goccy/go-yaml"
)

const (
	yamlEncoderIndentSpaces = 2
	releasePlanTargetChunks = 2
	commitMessageTemplate   = `[release] {{.FirstModuleID}} version {{.FirstModuleVersion}}{{if .OtherModulesCount}} (+{{.OtherModulesCount}} other modules){{end}}

Release message generated by #kaeter.
Please do not edit the part below until the end of the raw YAML Segment.

Release Plan:
` + "```lang=yaml" + `

{{.YamlReleasePlan}}
` + "```\n"
	conventionalCommitMessage = `chore(release): {{.FirstModuleID}} version {{.FirstModuleVersion}}{{if .OtherModulesCount}} (+{{.OtherModulesCount}} other modules){{end}}

Release message generated by #kaeter.
Please do not edit the part below (footer).

{{.YamlReleasePlan}}`
)

// Matching backticks in Go regexes is a ton of fun...
// the first (?s) enables multi-line matching for the dot (.) character.
// to avoid matching multiple code blocks since we can expect release plan code blocks
// NOT to contain back ticks we can match any non back tick character
// because literal strings are delimited we use the hex value (aka \u0060) of the back tick
var releasePlanRegex = regexp.MustCompile(
	`(?s).*Release Plan:(?:\n|\r\n?){1,2}` + "```" + `(?:lang=yaml)?(?:\n|\r\n?){1,2}([^\x60]*)` + "```")

const (
	ReleasePlanPrefix              = "Release-Plan"
	releasePlanRegexExpectedGroups = 2
)

var prReleasePlanRegexp = regexp.MustCompile(fmt.Sprintf(
	"(?m)^%s: .+$\r?\n?",
	regexp.QuoteMeta(ReleasePlanPrefix),
))

type rawReleasePlan struct {
	Releases []string `yaml:"releases"`
}

// ReleasePlan references one or more modules to be released.
type ReleasePlan struct {
	Releases []ReleaseTarget `json:",omitempty"`
}

// ReleaseTarget represents a single module to be released. It is identified by its module id and
// contains the version to be released
type ReleaseTarget struct {
	ModuleID string `json:",omitempty"`
	Version  string `json:",omitempty"`
}

// SingleReleasePlan is a convenience function to create a release plan for a single module (the most common use case)
func SingleReleasePlan(moduleID, moduleVersion string) *ReleasePlan {
	return &ReleasePlan{Releases: []ReleaseTarget{{moduleID, moduleVersion}}}
}

// Marshal returns a simple string representation of this object in the form <module_id>:<version>.
// Note that it is safe to have a colon (:) in the module id itself, as long as #ReleasePlanFromYaml() is used
// to read this back.
func (rt *ReleaseTarget) Marshal() string {
	return rt.ModuleID + ":" + rt.Version
}

// ReleasePlanFromCommitMessage expects to receive a complete commit message containing a YAML release plan
// formatted in markdown within some triple back ticks (```) like so:
//
// [release] $moduleId version $version
//
// Release message generated by #kaeter.
// Please do not edit the part below until the end of the raw YAML Segment.
//
// Release Plan:
// ```lang=yaml
//
// <RELEASE_PLAN_HERE>
// ```
// It will read the release plan and return an unmarshaled object from it.
func ReleasePlanFromCommitMessage(commitMsg string) (*ReleasePlan, error) {
	if prReleasePlanRegexp.MatchString(commitMsg) {
		releasePlans := prReleasePlanRegexp.FindAllString(commitMsg, -1)
		releases := make([]ReleaseTarget, len(releasePlans))
		for i, plan := range releasePlans {
			target := strings.TrimPrefix(plan, ReleasePlanPrefix+": ")
			splitStr := strings.Split(target, ":")
			if len(splitStr) < releasePlanTargetChunks {
				return nil, fmt.Errorf("invalid release target: %s", plan)
			}
			versionIdx := len(splitStr) - 1
			releases[i] = ReleaseTarget{
				ModuleID: strings.Join(splitStr[0:versionIdx], ":"),
				Version:  strings.TrimSpace(splitStr[versionIdx]),
			}
		}
		return &ReleasePlan{releases}, nil
	}
	// DEPRECATED: keep support for yaml release plan in commit message body for now.
	groups := releasePlanRegex.FindStringSubmatch(commitMsg)
	if len(groups) != releasePlanRegexExpectedGroups {
		return nil, errors.New("could not extract release plan from commit message")
	}
	return ReleasePlanFromYaml(groups[1])
}

// DEPRECATED
// ReleasePlanFromYaml reads a release plan from a clean YAML string, as it was created by #ToYamlString()
func ReleasePlanFromYaml(yamlStr string) (*ReleasePlan, error) {
	var rawReleases rawReleasePlan
	err := yaml.Unmarshal([]byte(yamlStr), &rawReleases)
	if err != nil {
		return nil, err
	}
	if len(rawReleases.Releases) == 0 {
		return nil, errors.New("did not find any releases in the passed yaml string")
	}

	releases := make([]ReleaseTarget, len(rawReleases.Releases))
	for i, rawData := range rawReleases.Releases {
		splitStr := strings.Split(rawData, ":")
		if len(splitStr) < releasePlanTargetChunks {
			return nil, fmt.Errorf("invalid release target: %s", rawData)
		}
		versionIdx := len(splitStr) - 1
		releases[i] = ReleaseTarget{
			ModuleID: strings.Join(splitStr[0:versionIdx], ":"),
			Version:  splitStr[versionIdx],
		}
	}

	return &ReleasePlan{releases}, nil
}

// DEPRECATED
// ToYamlString writes the specifics of this release plan to YAML. The returned YAML
// will only contain the release targets.
func (rp *ReleasePlan) ToYamlString() (string, error) {
	targetStrings := make([]string, len(rp.Releases))
	for i, target := range rp.Releases {
		targetStrings[i] = target.Marshal()
	}
	var b bytes.Buffer
	yamlEncoder := yaml.NewEncoder(&b,
		yaml.Indent(yamlEncoderIndentSpaces),
		yaml.IndentSequence(true))
	defer yamlEncoder.Close()
	err := yamlEncoder.Encode(&rawReleasePlan{targetStrings})
	if err != nil {
		return "", err
	}

	return b.String(), nil
}

// ToFooters returns a simple string representation of this release plan
// where each release target is represented as <module_id>:<version>.
func (rp *ReleasePlan) ToFooters() (string, error) {
	var footer strings.Builder
	for _, target := range rp.Releases {
		_, err := footer.WriteString(fmt.Sprintf("%s: %s\n", ReleasePlanPrefix, target.Marshal()))
		if err != nil {
			return "", err
		}
	}
	return footer.String(), nil
}

// formattingStruct is used to replace the template variables in commitMessageTemplate
type formattingStruct struct {
	FirstModuleID      string
	FirstModuleVersion string
	YamlReleasePlan    string
	OtherModulesCount  int
}

// ToCommitMessage serializes this release plan to a complete commit message
// that can be passed as-is to git.
func (rp *ReleasePlan) ToCommitMessage() (string, error) {
	if len(rp.Releases) == 0 {
		return "", errors.New("cannot write empty release plan to commit message")
	}
	if os.Getenv("ALLOW_CC") == "1" {
		// Use conventional commit format
		releases, err := rp.ToFooters()
		if err != nil {
			return "", err
		}
		tmpl, err := template.New("Commit Message").Parse(conventionalCommitMessage)
		if err != nil {
			return "", err
		}
		var buf bytes.Buffer
		err = tmpl.Execute(&buf, formattingStruct{
			rp.Releases[0].ModuleID,
			rp.Releases[0].Version,
			releases,
			len(rp.Releases) - 1,
		})
		if err != nil {
			return "", err
		}
		return buf.String(), nil
	}
	// DEPRECATED: use old format
	yamlStr, err := rp.ToYamlString()
	if err != nil {
		return "", err
	}
	tmpl, err := template.New("Commit Message").Parse(commitMessageTemplate)
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, formattingStruct{
		rp.Releases[0].ModuleID,
		rp.Releases[0].Version,
		yamlStr,
		len(rp.Releases) - 1,
	})
	if err != nil {
		return "", err
	}
	return buf.String(), nil
}

// HasReleasePlan returns true if the passed string (expected to be a commit message) seems to contain a release plan.
// This will check that:
//   - DEPRECATED: there is a [release] tag somewhere in the passed message
//   - there is a Release-Plan: footer (conventional commit)
//   - we can extract a release plan from the rest of the body.
func HasReleasePlan(commitMsg string) bool {
	if prReleasePlanRegexp.MatchString(commitMsg) {
		return true
	}
	// DEPRECATED: keep support for yaml release plan in commit message body for now.
	if !strings.Contains(commitMsg, "[release]") {
		return false
	}
	_, err := ReleasePlanFromCommitMessage(commitMsg)
	return err == nil
}
