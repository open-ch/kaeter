package actions

import (
	"os"
	"path"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

const testReleasePlanYaml = `releases:
  - someId:1.2.3
  - groupId:moduleId:4.5.6
  - stringVerId:moduleId:StringVerLulz
`
const testComplexVersionReleasePlanYaml = `releases:
  - complexVersioning:moduleId:v1.2.3+beta1
`

func getTestCommitMsg(t *testing.T, filename string) string {
	bytes, err := os.ReadFile(path.Join("testdata/" + filename))
	assert.NoError(t, err)
	return string(bytes)
}

func TestHasReleasePlan(t *testing.T) {
	var tests = []struct {
		name          string
		commitMessage string
		expectPlan    bool
	}{
		{
			name:          "The test commit message should be recognized",
			commitMessage: getTestCommitMsg(t, "test-commit-message.txt"),
			expectPlan:    true,
		},
		{
			name:          "Release plan with second code block after it",
			commitMessage: getTestCommitMsg(t, "release-commit-message-multiple-code-blocks.txt"),
			expectPlan:    true,
		},
		{
			name:          "Without the leading [release] string, this method should return false.",
			commitMessage: strings.TrimPrefix(getTestCommitMsg(t, "test-commit-message.txt"), "[release]"),
		},
		{
			name: "Correct header but without plan",
			commitMessage: `[release] this is not really a release plan, but starts in the same way.

This is a nice commit message.

Thank you and good-bye.
`,
		},
		{
			name: "If Autorelease, this method should return false.",
			commitMessage: `chore(test): unit test
Autorelease-Plan: unit:test:0.0.0
`,
		},
		{
			name: "If conventional commit, this method should return true.",
			commitMessage: `chore(test): unit test
Release-Plan: unit:test:0.0.0
`,
			expectPlan: true,
		},
		{
			name: "If conventional commit multiple releases, this method should return true.",
			commitMessage: `chore(test): unit test
Release-Plan: unit:test:0.0.0
Release-Plan: unit:test2:0.0.0
`,
			expectPlan: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			hasPlan := HasReleasePlan(tc.commitMessage)

			assert.Equal(t, tc.expectPlan, hasPlan)
		})
	}
}

func TestReleasePlanFromCommitMessage(t *testing.T) {
	var tests = []struct {
		name          string
		rp            *ReleasePlan
		commitMessage string
	}{
		{
			name: "single module plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"groupId:module2", "2.4.0"},
				},
			},
			commitMessage: `chore(release): groupId:module2 version 2.4.0

Release message generated by #kaeter.
Please do not edit the part below (footer).

Release-Plan: groupId:module2:2.4.0
`,
		},
		{
			name: "multiple module plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"groupId:module2", "2.4.0"},
					{"stringVerId:moduleId", "StringVerLulz"},
				},
			},
			commitMessage: `chore(release): groupId:module2 version 2.4.0 (+1 other modules)

Release message generated by #kaeter.
Please do not edit the part below (footer).

Release-Plan: groupId:module2:2.4.0
Release-Plan: stringVerId:moduleId:StringVerLulz
`,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			assert.True(t, HasReleasePlan(tc.commitMessage))

			plan, err := ReleasePlanFromCommitMessage(tc.commitMessage)

			assert.NoError(t, err)
			assert.Equal(t, tc.rp, plan)
		})
	}
}

func TestReleasePlanFromConventionalCommitMessage(t *testing.T) {
	var tests = []struct {
		name          string
		rp            *ReleasePlan
		commitMessage string
	}{
		{
			name: "single module plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"groupId:module2", "2.4.0"},
				},
			},
			commitMessage: getTestCommitMsg(t, "single-module-test-commit-message.txt"),
		},
		{
			name: "multiple module plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"groupId:module2", "2.4.0"},
					{"nonMavenId", "3.4.0"},
					{"stringVerId:moduleId", "StringVerLulz"},
				},
			},
			commitMessage: getTestCommitMsg(t, "test-commit-message.txt"),
		},
		{
			name: "complex version module plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"complexVersioning:moduleId", "v1.2.3+beta1"},
				},
			},
			commitMessage: getTestCommitMsg(t, "complex-version-test-commit-message.txt"),
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			assert.True(t, HasReleasePlan(tc.commitMessage))

			plan, err := ReleasePlanFromCommitMessage(tc.commitMessage)

			assert.NoError(t, err)
			assert.Equal(t, tc.rp, plan)
		})
	}
}

func TestToConventionalCommitMessage(t *testing.T) {
	var tests = []struct {
		name          string
		rp            *ReleasePlan
		commitMessage string
	}{
		{
			name: "single module plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"groupId:module2", "2.4.0"},
				},
			},
			commitMessage: `chore(release): groupId:module2 version 2.4.0

Release message generated by #kaeter.
Please do not edit the part below (footer).

Release-Plan: groupId:module2:2.4.0
`,
		},
		{
			name: "multiple module plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"groupId:module2", "2.4.0"},
					{"stringVerId:moduleId", "StringVerLulz"},
				},
			},
			commitMessage: `chore(release): groupId:module2 version 2.4.0 (+1 other modules)

Release message generated by #kaeter.
Please do not edit the part below (footer).

Release-Plan: groupId:module2:2.4.0
Release-Plan: stringVerId:moduleId:StringVerLulz
`,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Setenv("ALLOW_CC", "1")
			commitMsg, err := tc.rp.ToCommitMessage()

			assert.NoError(t, err)
			assert.Equal(t, tc.commitMessage, commitMsg)
		})
	}
}

func TestReleasePlanFromYaml(t *testing.T) {
	plan, err := ReleasePlanFromYaml(testReleasePlanYaml)
	assert.NoError(t, err)
	assert.NotNil(t, plan)
	assert.Equal(
		t,
		&ReleasePlan{
			[]ReleaseTarget{
				{"someId", "1.2.3"},
				{"groupId:moduleId", "4.5.6"},
				{"stringVerId:moduleId", "StringVerLulz"},
			},
		},
		plan)
}

func TestToYamlString(t *testing.T) {
	var tests = []struct {
		name string
		rp   *ReleasePlan
		yaml string
	}{
		{
			name: "basic release plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"someId", "1.2.3"},
					{"groupId:moduleId", "4.5.6"},
					{"stringVerId:moduleId", "StringVerLulz"},
				},
			},
			yaml: testReleasePlanYaml,
		},
		{
			name: "complex version numbers",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"complexVersioning:moduleId", "v1.2.3+beta1"},
				},
			},
			yaml: testComplexVersionReleasePlanYaml,
		},
	}

	for _, tc := range tests {
		releasePlanYaml, err := tc.rp.ToYamlString()

		assert.NoError(t, err, tc.name)
		assert.Equal(t, tc.yaml, releasePlanYaml, tc.name)
	}
}

func TestToFooter(t *testing.T) {
	var tests = []struct {
		name     string
		rp       *ReleasePlan
		expected string
	}{
		{
			name: "empty release plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{},
				},
			},
			expected: `Release-Plan: :
`,
		},
		{
			name: "basic release plan",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"someId", "1.2.3"},
					{"groupId:moduleId", "4.5.6"},
					{"stringVerId:moduleId", "StringVerLulz"},
				},
			},
			expected: `Release-Plan: someId:1.2.3
Release-Plan: groupId:moduleId:4.5.6
Release-Plan: stringVerId:moduleId:StringVerLulz
`,
		},
		{
			name: "complex version numbers",
			rp: &ReleasePlan{
				[]ReleaseTarget{
					{"complexVersioning:moduleId", "v1.2.3+beta1"},
				},
			},
			expected: `Release-Plan: complexVersioning:moduleId:v1.2.3+beta1
`,
		},
	}

	for _, tc := range tests {
		releasePlan, err := tc.rp.ToFooters()

		assert.NoError(t, err, tc.name)
		assert.Equal(t, tc.expected, releasePlan, tc.name)
	}
}
